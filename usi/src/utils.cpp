//
// Created by hrxiong on 17/3/22.
//

#include "utils.h"

#include <cmath>
#include <algorithm>

ts_type saxBreakPoints[255] = {-2.660067468617458, -2.4175590162365035, -2.2662268092096522, -2.1538746940614573, -2.063527898316245, -1.9874278859298962, -1.921350774293703, -1.8627318674216515, -1.8098922384806087, -1.7616704103630665, -1.7172281175057411, -1.6759397227734438, -1.637325382768064, -1.601008664886076, -1.5666885860684134, -1.534120544352546, -1.5031029431292737, -1.4734675779471014, -1.4450725798180746, -1.4177971379962677, -1.3915374879959008, -1.3662038163720984, -1.341717841080254, -1.318010897303537, -1.2950224067058147, -1.2726986411905359, -1.2509917154625454, -1.229858759216589, -1.209261231709155, -1.189164350199337, -1.169536610207143, -1.1503493803760083, -1.131576558386188, -1.113194277160929, -1.0951806527613883, -1.0775155670402805, -1.0601804794353549, -1.0431582633184537, -1.0264330631379108, -1.0099901692495823, -0.993815907860883, -0.9778975439405418, -0.9622231952954206, -0.946781756301046, -0.9315628300071148, -0.9165566675331128, -0.9017541138301002, -0.8871465590188762, -0.8727258946270402, -0.858484474141832, -0.8444150773752572, -0.8305108782053992, -0.8167654153150912, -0.8031725655979178, -0.7897265199432658, -0.7764217611479275, -0.7632530437325706, -0.7502153754679404, -0.7373040004386545, -0.7245143834923653, -0.711842195939419, -0.69928330238322, -0.6868337485747303, -0.6744897501960819, -0.6622476824884141, -0.6501040706479954, -0.6380555809225171, -0.6260990123464211, -0.6142312890602454, -0.6024494531644237, -0.5907506580628189, -0.5791321622555561, -0.5675913235445692, -0.5561255936186916, -0.5447325129881759, -0.5334097062412806, -0.5221548775980015, -0.5109658067382474, -0.4998403448837353, -0.4887764111146696, -0.4777719889038861, -0.46682512285258965, -0.4559339156131388, -0.44509652498551644, -0.4343111611752096, -0.42357608420119974, -0.41288960144365433, -0.40225006532172536, -0.3916558710925915, -0.3811054547635565, -0.3705972911096293, -0.36012989178956945, -0.3497018035538953, -0.3393116065388173, -0.3289579126404911, -0.31863936396437526, -0.30835463134483726, -0.2981024129304869, -0.2878814328310118, -0.27769043982157676, -0.2675282061010972, -0.25739352610093835, -0.24728521534080486, -0.2372021093287877, -0.22714306250271535, -0.2171069472101298, -0.2070926527243603, -0.19709908429431236, -0.18712516222572084, -0.17716982099173986, -0.16723200837085014, -0.15731068461017073, -0.14740482161235488, -0.13751340214433597, -0.12763541906627035, -0.11776987457909531, -0.10791577948918657, -0.0980721524886611, -0.08823801944992447, -0.07841241273311222, -0.06859437050511813, -0.05878293606894307, -0.04897715720213194, -0.03917608550309764, -0.02937877574415705, -0.019584285230126924, -0.009791673161345348, 0.0, 0.009791673161345348, 0.019584285230126924, 0.02937877574415705, 0.03917608550309764, 0.04897715720213194, 0.05878293606894307, 0.06859437050511813, 0.07841241273311222, 0.08823801944992447, 0.0980721524886611, 0.10791577948918657, 0.11776987457909531, 0.12763541906627035, 0.13751340214433597, 0.14740482161235488, 0.15731068461017073, 0.16723200837085014, 0.17716982099173986, 0.18712516222572084, 0.19709908429431236, 0.2070926527243603, 0.2171069472101298, 0.22714306250271535, 0.2372021093287877, 0.24728521534080486, 0.25739352610093835, 0.2675282061010972, 0.27769043982157676, 0.2878814328310118, 0.2981024129304869, 0.30835463134483726, 0.31863936396437526, 0.3289579126404911, 0.3393116065388173, 0.3497018035538953, 0.36012989178956945, 0.3705972911096293, 0.3811054547635565, 0.3916558710925915, 0.40225006532172536, 0.41288960144365433, 0.42357608420119974, 0.4343111611752096, 0.44509652498551644, 0.4559339156131388, 0.46682512285258965, 0.4777719889038861, 0.4887764111146696, 0.4998403448837353, 0.5109658067382474, 0.5221548775980015, 0.5334097062412806, 0.5447325129881759, 0.5561255936186916, 0.5675913235445692, 0.5791321622555561, 0.5907506580628189, 0.6024494531644237, 0.6142312890602454, 0.6260990123464211, 0.6380555809225171, 0.6501040706479954, 0.6622476824884141, 0.6744897501960819, 0.6868337485747303, 0.69928330238322, 0.711842195939419, 0.7245143834923653, 0.7373040004386545, 0.7502153754679404, 0.7632530437325706, 0.7764217611479275, 0.7897265199432658, 0.8031725655979178, 0.8167654153150912, 0.8305108782053992, 0.8444150773752572, 0.858484474141832, 0.8727258946270402, 0.8871465590188762, 0.9017541138301002, 0.9165566675331128, 0.9315628300071148, 0.946781756301046, 0.9622231952954206, 0.9778975439405418, 0.993815907860883, 1.0099901692495823, 1.0264330631379108, 1.0431582633184537, 1.0601804794353549, 1.0775155670402805, 1.0951806527613883, 1.113194277160929, 1.131576558386188, 1.1503493803760083, 1.169536610207143, 1.189164350199337, 1.209261231709155, 1.229858759216589, 1.2509917154625454, 1.2726986411905359, 1.2950224067058147, 1.318010897303537, 1.341717841080254, 1.3662038163720984, 1.3915374879959008, 1.4177971379962677, 1.4450725798180746, 1.4734675779471014, 1.5031029431292737, 1.534120544352546, 1.5666885860684134, 1.601008664886076, 1.637325382768064, 1.6759397227734438, 1.7172281175057411, 1.7616704103630665, 1.8098922384806087, 1.8627318674216515, 1.921350774293703, 1.9874278859298962, 2.063527898316245, 2.1538746940614573, 2.2662268092096522, 2.4175590162365035, 2.660067468617458};

sax_type getSAXFromPAA(ts_type paa)
{
    int l = 0, r = 254, m;
    while (l < r)
    {
        m = (l + r + 1) / 2;
        if (saxBreakPoints[m] <= paa)
        {
            l = m;
        }
        else
        {
            r = m - 1;
        }
    }
    if (saxBreakPoints[0] > paa)
        return 0;
    return r + 1;
}

ts_type getSAXLowerBP(sax_type sax)
{
    return sax == 0 ? -INF : saxBreakPoints[sax - 1];
}

ts_type getSAXUpperBP(sax_type sax)
{
    return sax == 255 ? INF : saxBreakPoints[sax];
}

void EnvInfoPAA::reset(file_position_type start)
{
    startIndex = start;
    cnt = 0;
    for (int i = 0; i < SEGMENTS; i++)
        PAAmin[i] = INF;
    for (int i = 0; i < SEGMENTS; i++)
        PAAmax[i] = -INF;
    for (int i = 0; i < SEGMENTS; i++)
        PAAkey[i] = 0;
    // fill(PAAmin, PAAmin + SEGMENTS, INF);
    // fill(PAAmax, PAAmax + SEGMENTS, -INF);
    meanMin = INF;
    meanMax = -INF;
    stdMin = INF;
    stdMax = -INF;
}

void EnvInfoSAX::setByPAAEnv(struct EnvInfoPAA &env)
{
    startIndex = env.startIndex;
    minl = env.minl;

    ex = env.ex;
    ex2 = env.ex2;
    meanMin = env.meanMin;
    meanMax = env.meanMax;
    stdMin = env.stdMin;
    stdMax = env.stdMax;

    int i;
    for (i = 0; i < SEGMENTS; i++)
        SAXmin[i] = getSAXFromPAA(env.PAAmin[i]);
    for (i = 0; i < SEGMENTS; i++)
        SAXmax[i] = getSAXFromPAA(env.PAAmax[i]);
    for (i = 0; i < SEGMENTS; i++)
        SAXkey[i] = getSAXFromPAA(env.PAAkey[i]);
}

void norm(ts_type *data, file_position_type l)
{
    file_position_type i = 0;
    ts_type d, ex = 0, ex2 = 0, mean, std;
    while (i < l)
    {
        d = data[i];
        ex += d;
        ex2 += d * d;
        i++;
    }
    mean = ex / l;
    std = ex2 / l;
    std = sqrt(std - mean * mean);
    for (i = 0; i < l; i++)
        data[i] = (data[i] - mean) / std;
}


/// Initial the queue at the begining step of envelop calculation
void init(lb_deque *d, int capacity)
{
    d->capacity = capacity;
    d->size = 0;
    d->dq = (int *) malloc(sizeof(int)*d->capacity);
    d->f = 0;
    d->r = d->capacity-1;
}

/// Insert to the queue at the back
void push_back(struct lb_deque *d, int v)
{
    d->dq[d->r] = v;
    d->r--;
    if (d->r < 0)
        d->r = d->capacity-1;
    d->size++;
}

/// Delete the current (front) element from queue
void pop_front(struct lb_deque *d)
{
    d->f--;
    if (d->f < 0)
        d->f = d->capacity-1;
    d->size--;
}

/// Delete the last element from queue
void pop_back(struct lb_deque *d)
{
    d->r = (d->r+1)%d->capacity;
    d->size--;
}

/// Get the value at the current position of the circular queue
int front(struct lb_deque *d)
{
    int aux = d->f - 1;

    if (aux < 0)
        aux = d->capacity-1;
    return d->dq[aux];
}

/// Get the value at the last position of the circular queueint back(struct lb_deque *d)
int back(struct lb_deque *d)
{
    int aux = (d->r+1)%d->capacity;
    return d->dq[aux];
}

/// Check whether or not the queue is empty
int empty(struct lb_deque *d)
{
    return d->size == 0;
}


/// Destroy the queue
void destroy(lb_deque *d)
{
    free(d->dq);
}


/// Finding the envelop of min and max value for LB_Keogh
/// Implementation idea is intoruduced by Danial Lemire in his paper
/// "Faster Retrieval with a Two-Pass Dynamic-Time-Warping Lower Bound", Pattern Recognition 42(9), 2009.
void lower_upper_lemire(ts_type *t, int len, int r, ts_type *l, ts_type *u)
{
    struct lb_deque du, dl;

    init(&du, 2*r+2);
    init(&dl, 2*r+2);

    push_back(&du, 0);
    push_back(&dl, 0);
    int i;
    
    for (i = 1; i < len; i++)
    {
        if (i > r)
        {
            u[i-r-1] = t[front(&du)];
            l[i-r-1] = t[front(&dl)];
        }
        if (t[i] > t[i-1])
        {
            pop_back(&du);
            while (!empty(&du) && t[i] > t[back(&du)])
                pop_back(&du);
        }
        else
        {
            pop_back(&dl);
            while (!empty(&dl) && t[i] < t[back(&dl)])
                pop_back(&dl);
        }
        push_back(&du, i);
        push_back(&dl, i);
        if (i == 2 * r + 1 + front(&du))
            pop_front(&du);
        else if (i == 2 * r + 1 + front(&dl))
            pop_front(&dl);
    }
    for (i= len; i < len+r+1; i++)
    {
        u[i-r-1] = t[front(&du)];
        l[i-r-1] = t[front(&dl)];
        if (i-front(&du) >= 2 * r + 1)
            pop_front(&du);
        if (i-front(&dl) >= 2 * r + 1)
            pop_front(&dl);
    }
    destroy(&du);
    destroy(&dl);
}
